plugins {
    id 'java'
    id 'application'
    id 'antlr'
}

java {
    sourceCompatibility = JavaVersion.VERSION_21
}

version = project.project_version
group = ""

repositories {
    mavenCentral()
}

dependencies {
    antlr("org.antlr:antlr4:$project.antlr_version")
    implementation("org.antlr:antlr4-runtime:$project.antlr_version")
}

def mainClass = "${project.src_root_name}.Compiler"
def lexanDir = "src/${project.src_root_name}/phase/lexan"
def synanDir = "src/${project.src_root_name}/phase/synan"
def phaseDir = "src/${project.src_root_name}/phase"
def lexerName = project.lexer_file_name
def parserName = project.parser_file_name

sourceSets {
    main {
        java {
            srcDirs = ['src']
        }
        antlr {
            srcDirs = [lexanDir]
        }
    }
}

generateGrammarSource {
    source {
        include("${lexerName}.g4")
        outputDirectory = file(lexanDir)
    }
    source {
        include("${parserName}.g4")
        outputDirectory = file(synanDir)
    }

    // For some reason, the generated lexer is placed in the synan directory
    doLast {
        // Move generated lexer to the phase directory
        copy {
            from fileTree(synanDir)
            into file(lexanDir)
            include "${lexerName}.java"
            include "${lexerName}.interp"
            include "${lexerName}.tokens"
            include "${lexerName}.java-orig"
        }
        // Delete generated lexer from the synan directory
        delete fileTree(synanDir) {
            include "${lexerName}.java"
            include "${lexerName}.interp"
            include "${lexerName}.tokens"
            include "${lexerName}.java-orig"
        }
    }
}

application {
    mainClassName = mainClass
}

jar {
    // Fat jar (include all dependencies)
    from {
        configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) }
    }

    // Specify the main class when launching the jar
    manifest {
        attributes(
                'Main-Class': mainClass
        )
    }
}

clean {
    delete file("$lexanDir/${lexerName}.java")
    delete file("$lexanDir/${lexerName}.java-orig")
    delete file("$lexanDir/${lexerName}.interp")
    delete file("$lexanDir/${lexerName}.tokens")

    delete file("$synanDir/${parserName}.java")
    delete file("$synanDir/${parserName}.java-orig")
    delete file("$synanDir/${parserName}.interp")
    delete file("$synanDir/${parserName}.tokens")

    // Remove generated program xml and html files
    delete fileTree("prg", {
        it.include("*.xml", "*.html")
    })
}

// todo
tasks.register('testProgram', Test) {
    dependsOn(compileJava, compileTestJava)
    description = "Runs the compiler for specified test file."

    testClassesDirs = sourceSets.main.output.classesDirs
    classpath = sourceSets.main.runtimeClasspath

    def fileExtension = project.source_file_extension
    def loggedPhase = project.hasProperty('loggedPhase') ? project.loggedPhase : "all"
    def targetPhase = project.hasProperty('targetPhase') ? project.targetPhase : "all"

    if (!project.hasProperty('file')) {
        throw new GradleException("No file specified. Use -Pfile=<file>")
    }

    def prgDir = file('prg/')
    // Test the specified file
    def testFile = file(prgDir.path + "/" + project.file + ".$fileExtension")
    println("Testing file: $testFile.name")
    doLast {
        println("is file: ${testFile.isFile()}, ends with: ${testFile.name.endsWith(".$fileExtension")} ")
        if (testFile.isFile() && testFile.name.endsWith(".$fileExtension")) {
            println("Testing file: $testFile.name")

            // Run the compiler with "--src-file-name=file.name"
            exec {
                workingDir prgDir
                commandLine 'java',
                        "-cp", classpath.asPath, mainClass,
                        "--xsl=../lib/xsl/",
                        "--logged-phase=$loggedPhase",
                        "--target-phase=$targetPhase",
                        "--src-file-name=$testFile.name"
            }
        }
    }
}
